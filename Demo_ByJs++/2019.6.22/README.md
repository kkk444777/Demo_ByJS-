<h3>【小野老师面授01】2019.6.22号：主要包含了每日一题讲解，一个DOM小项目选项卡的讲解</h3>
<h4>1：2019.6.22号的每日一题: 实现一个三栏布局的网页，中间部分要自适应宽度，左边固定宽度150px,右边固定宽度200px</h4>
<p>1：圣杯布局</p>
<ul>
<li>     圣杯布局：是一个典型的三栏布局，中间自适应，左右固定宽度 </li>
<li>     左右固定，中间实现自适应,中间一栏要实现优先加载，那么DOM结构必须中间一栏先写好，高度都要100% </li> 
<li>     1:加一个大盒子，然后用padding让中间栏居中 </li>
<li>     2:左右两栏用浮动，然后用相对定位 </li>
<li>     3:左边一栏，先移动自身的宽度，往左边走，归零，然后相对定位-100%，左边一栏上去 </li>
<li>     4:右边一栏，先相对定位-100%，让它上去，然后margin-left100%，让它过去右边  </li>
</ul>
<p>2：双飞翼布局</p>
<ul>
<li> 双飞翼布局:也是一个典型的三栏布局，整体布局呈现效果与圣杯布局一样，但是在DOM结构有一点不同，双飞翼布局需要设置多一个内容盒子，让它在中间呈现 </li>
<li> 同样也是左右固定，中间自适应，中间一栏在DOM结构中优先书写 </li>
<li> 双飞翼用的左中右浮动，不用position:relative，所以在类名上最好写公共样式</li>
<li> 左边一栏：写个margin-left:-100%就上去了，因为float:left的缘故，加个margin,左边就能缩上去的 </li>
<li> 右边一栏：margin-left:-200px也上去了</li>
<li> 中间一栏必须设置多一个内容盒子让它居中，不然直接在middle里面写东西是看不到的，因为被左边的遮挡住了</li>
</ul>
<p>
    总结：圣杯布局与双飞翼布局不同的是，圣杯布局在大盒子里面用padding,让中间栏过来。此时大盒子依然在盒子模型里面撑开整个网页的宽度,左右两栏浮动 
    也因为padding和float:left的关系，左右在中间栏下面排列布局，然后你要左右两栏上去，在网页左边右边。
    你要在左右两栏先设置外边距，抵消到padding值，左：margin-left自身宽度，右：margin-left:-100%，归零，然后再用相对定位100%,就都上去了.
</p>
<hr />
<h4>2：2019.6.20号的每日一题:给一个body的ul动态添加50个li，并实现每一个li的删除功能(考虑性能优化)</h4>
<ul>
<li>此题应主要点为：1：动态创建li的性能优化 2:点击删除功能绑定的性能优化 3:三种解决方式</li>
<li>方式一：</li>
<li>第1点：动态创建li的性能优化，可以document.createDocumentFragment()文档碎片来解决。</li>
<li>第2点:点击功能优化，也就是为事件代理（利用事件冒泡机制）来解决，文档碎片 + 事件代理 + 事件源对象，也就是第一种解决方式</li>
<li>方式二：</li> 
<li>第1点：字符串拼接方式来完成动态创建li的性能优化。</li>
<li>第2点：点击功能优化，依旧是事件代理 + 事件源对象，字符串拼接，然后再去设置innerHTML.点击功能优化与第一种相同，字符串拼接 + 事件代理 + 事件源对象，这也是第二种解决方式</li>
<li>方式三：</li>
<li>第1点:还是使用字符串拼接方式还是，但是不用去设置其innerHTML，直接扔一个模板，然后用正则去匹配跟替换</li>
<li>第2点:点击功能优化依旧是使用事件代理 + 事件源对象。  
</ul>
<hr />
<h4>3：2019.6.21号的每日一题:以下分别打印的结果是什么，为什么?</h4>
<h4>1:({} + {}).length 2:([] + []).length 3:(function (){}).length</h4>
<ul>
<li>第一道题：要点在于隐式转换，然后调用的是{}.toString。也是Object.prototype.toString.
<p>Object.prototype.toString跟Array.prototype.toString在方法的使用上面是有所不同的。[].toString，是把数组里面的内容转换成字符串，然后数组中的每一项在转换后，是用逗号隔开.</p>
<p>{}.toString与Object.prototype.toString的作用完全相同，只是在写法上有点不同，因为{}是Object字面量，字面量写法在使用已经实例化也就是new Object，且把自身的prototype指向Object.prototype，所以也就是{}能用Obejct.prototype上面的方法，这就是原型链继承</p>
<p>然后还有泛指对象，特指对象的概念。以'[object Object]'为例，前面小的object为泛指对象，后面大的Object为特指对象。经过{}.toString方法这么去过一下的数据类型出来的都是对象，哪怕是基本类型的字符串，数组，布尔值它们出来的前面也都是'[object]'，为啥？因为这时候后台，又给它临时包装类给包了一下，也就是临时包装类了.临时包装类是啥，也就是JavaScript一切皆为对象的神秘机制之一，我们都说在JavaScript中基本类型，字符串，数字，布尔.他们是不能拥有方法跟属性的，那么为什么字符串.length，这种写法不会报错，还有结果。这个时候就是包装类在作怪了，JavaScript会在后台中，临时给你这么搞一搞，包装对象，能够点语法，调用方法。包装完之后，又消失了.</p>
<p>举个例子：声明一个变量var a = 'a', var b = a.a.也就是把b作为a的属性，console.log(b)这个时候会不会报错？用基本类型使用对象才能使用的点语法，会不会报错？不会报错，是undefined.JavaScript临时给它整成了一个对象，但是包装完对象后，使用后又消失了，这就是临时嘛，临时给它包装成类，包装完后又消失了，所以就是临时包装类.</p>
<p>回到题目：({} + {}).length,这个时候{}是复杂数据类型，是对象，做不了一元加号的运算。在JavaScript后台中，默认调用了它的toString方法，把它转换成了一堆字符串'[object Object]'，然后就是'[object Object]' + '[object Object]'相加，取字符串长度，最后为30，即第一题为30</p>
</li>
<li><p>第二道题：同样也是隐式转换，但是这里调用的[].toStirng，也就是Array.prototype.toString()方法。</p></li>
<p>[].toString的方法作用是：把数组变成字符串，且每一项用逗号隔开。在这一题中[]是空数组，空数组转换字符串，也就是空串，空串长度为0，即0 + 0 = 0</p>
<li>
<p>第三道题：首先我们要明白，函数也就是Function的.length属性是什么的长度？才能很好的回答问题.那么可以先声明一个匿名函数 function(){}，然后声明形参
function(a){}，再打印一下console.log(function(a).length)，出来的结果是1，这样我们就很清晰的知道，Function.length属性就是形参的长度。那么回到题目
function(){}，里面没有形参，没有形参，那不就是0嘛？所以打印结果即为0
</li>
<li>最后封装了一个工具函数：用来检查值的类型：null则返回null,出现相对于的'[object Object]'就把它替换成自己封装对象里面的属性</li>
<hr />
<h4>4：TabCard选项卡，2种方式，1：循环增删类 2：下标增删类</h4> 
<h5>TabCard选项卡其中类名的增删切换有两种做法：第一种是常规的for循环增删类 第二种是使用下标索引增删类</h5>
<ul>
    <li>这里重点说明的是用下标索引去增删类，for循环增删类不在讲解的过程中</li>
    <li>下标增删类：首先用的是Array.prototype.indexOf.call方法找下标，即[].indexOf.call</li>
    <li>这里需要声明一个idx变量去保存，一个用来保存当前的下标用于增类，一个用于保存之前的下标用于删类。</li>
    <li>当前的下标变量赋值为[].indexOf(item的伪数组集合，tar)</li>
    <li>之前的下标先赋值为0，然后点击了上面的选项卡后，把当前的下标赋值给了之前的下标</li>
    <li>然后当你点击上面的选项卡的时候，页面内容需要联动进行变更，就可以把点击后的新的idx赋值给之前的旧的idx，那么你之前的idx项的类名需要清除的，就要这个旧的idx下标去清除类名，新的idx用来增加类名，新的idx用[].indexOf.call来获取。</li>
</ul>
<hr />   
<h4>2019.6.23号收集到一条怪题，来自匡哥的学生,我把题目拓展了一下：1 + [1] = ?  1 + [1,1] = ? 1 + [{}] = ？</h4>
<ul>
<li><p>首先我们已经知道：在JavaScript中引用类型不能用来做一元加法运算符的运算，所以这里必定会涉及到一个隐式转换的问题，上次我们知道了{}.toString
还有[].toString一个是对象原型上的toString方法，一个数组原型上的toString方法，根据调用对象不同，返回的结果不同，{}.toString会把目标转换成字符串的'[object Object]'，而[].toString会把数组变成字符串形式，且项与项之间用逗号分隔开,那么这里我还是用数组的做法来讲解一下，后面再来说下这个valueOf.
</p></li>
<p>回到第一题：1 + [1] = ? </p>
<p>先来看看[1]会变成什么东西？[1]即一个数组里面有一个Number类型的1，然后数组调用自身toString方法，把自己变成字符串的'1'，1 + '1'即Number类型1
加上Strign的'1',这就整成了字符串拼接，既然是字符串拼接了，结果自然是字符串的'11'</p>
<p>第二题： 1 + [{}] = ? </p>
<p>在这里[{}]是啥东西阿？不就是数组里面放了一个对象吗？对象的隐式转换是啥？不就是一堆字符串嘛。'[object Object]' 那么1 + 字符串的'[object Object]'是啥？字符串拼接阿，能是啥，所以结果是'1[object Object]'
<p>第三题： 1 + [1,1] = ? </p>
<p>这个同第一题已经大同小异了，如果能理解第一道题的话，那么第三道题也应该不成问题。还是调用数组上面的toString方法，把数组变成字符串,项与项之间用逗号隔开也就是变成字符串'1,1'了，1 + '1,1'还是字符串拼接，结果即为'11,1'.
<li>讲完了题目，我们在后面再来说说这个valueOf,valueOf是一种将对象转换成原始值的方法。数组原型上的valueOf与对象原型上的valueOf相同，都是把对象转换成原始值，且在涉及到做运算符号做运算的时候，valueOf的优先级要高于toString,也就是说在valueOf失效后，无法将对象转换成原始值的时候，这个时候再调用toString</li>
<p>我们可以做一个例子测试一下：先声明一个var a = [3]</p>
<p>重写valueOf跟toString方法，测试其优先级别。 a.valueOf = function(){return 1} a.toString = function(){return 2}</p>
<p>然后我们再console.log(a + 1) ，结果是2，我们改写了valueOf，里面是return 1，现在a + 1 = 2，即a就是1，说明valueOf执行优先级别要高于toString</p>
<p>再来看看下一个情况，那么当valueOf里面返回是对象会怎么样？即a.valueOf = function(){return {}} a.toString = function(){return 2}</p>
<p>继续console.log(a + 1)，返回结果为3，toString里面我们返回了2，结果为3，说明最后执行了toString。这说明了一个情况，当我们valueOf里面是对象时候，valueOf搞不定了，这个时候toString再出来帮忙执行它的toString方法。那么这次测试是在一元加法运算的情况下做测试的，所以我们也可以说：在一元加法运算的情况下，复杂数据类型对象，数组会先执行它们原型上的valueOf方法，如果不能转换成原始值，再执行toString方法，变成一堆字符...'[object Object]' ''...
</ul>
    


